game = (

    TrajectoryGame{
      ProductDynamics{
        Tuple{
          LinearDynamics{
            FillArrays.Fill{Matrix{Float64}, 1, Tuple{InfiniteArrays.OneToInf{Int64}}}, 
            FillArrays.Fill{Matrix{Float64}, 1, Tuple{InfiniteArrays.OneToInf{Int64}}}, 
            @NamedTuple{lb::Vector{Float64}, ub::Vector{Float64}}, 
            @NamedTuple{lb::Vector{Int64}, 	ub::Vector{Int64}}
          }, 
          LinearDynamics{
            FillArrays.Fill{Matrix{Float64}, 1, Tuple{InfiniteArrays.OneToInf{Int64}}}, 
            FillArrays.Fill{Matrix{Float64}, 1, Tuple{InfiniteArrays.OneToInf{Int64}}}, 
            @NamedTuple{lb::Vector{Float64}, ub::Vector{Float64}}, 
            @NamedTuple{lb::Vector{Int64}, ub::Vector{Int64}}
          }
        }
      }, 
      TimeSeparableTrajectoryGameCost{
          TrajectoryGamesExamples.var"#stage_cost#35"{Float64, typeof(LinearAlgebra.norm)}, 
          TrajectoryGamesExamples.var"#reducer#36", ZeroSumCostStructure
      }, 
      PolygonEnvironment{LazySets.VPolytope{Float64, Vector{Float64}, Vector{Vector{Float64}}}}, 
      Nothing
    }
    dynamics: 
    ProductDynamics{
      Tuple{
        LinearDynamics{
          FillArrays.Fill{Matrix{Float64}, 1, Tuple{InfiniteArrays.OneToInf{Int64}}}, 
          FillArrays.Fill{Matrix{Float64}, 1, Tuple{InfiniteArrays.OneToInf{Int64}}}, 
          @NamedTuple{lb::Vector{Float64}, ub::Vector{Float64}}, 
          @NamedTuple{lb::Vector{Int64}, ub::Vector{Int64}}
        }, 
        LinearDynamics{
          FillArrays.Fill{Matrix{Float64}, 1, Tuple{InfiniteArrays.OneToInf{Int64}}}, 
          FillArrays.Fill{Matrix{Float64}, 1, Tuple{InfiniteArrays.OneToInf{Int64}}}, 
          @NamedTuple{lb::Vector{Float64}, ub::Vector{Float64}}, 
          @NamedTuple{lb::Vector{Int64}, ub::Vector{Int64}}}
      }
    }   
      subsystems: 
      Tuple{
        LinearDynamics{
          FillArrays.Fill{Matrix{Float64}, 1, Tuple{InfiniteArrays.OneToInf{Int64}}}, 
          FillArrays.Fill{Matrix{Float64}, 1, Tuple{InfiniteArrays.OneToInf{Int64}}}, 
          @NamedTuple{lb::Vector{Float64}, ub::Vector{Float64}}, 
          @NamedTuple{lb::Vector{Int64}, ub::Vector{Int64}}
        }, 
        LinearDynamics{
          FillArrays.Fill{Matrix{Float64}, 1, Tuple{InfiniteArrays.OneToInf{Int64}}}, 
          FillArrays.Fill{Matrix{Float64}, 1, Tuple{InfiniteArrays.OneToInf{Int64}}}, 
          @NamedTuple{lb::Vector{Float64}, ub::Vector{Float64}}, 
          @NamedTuple{lb::Vector{Int64}, ub::Vector{Int64}}
        }
      } 
      1: LinearDynamics{
        FillArrays.Fill{Matrix{Float64}, 1, Tuple{InfiniteArrays.OneToInf{Int64}}}, 
        FillArrays.Fill{Matrix{Float64}, 1, Tuple{InfiniteArrays.OneToInf{Int64}}},
        @NamedTuple{lb::Vector{Float64}, ub::Vector{Float64}}, 
        @NamedTuple{lb::Vector{Int64}, ub::Vector{Int64}}
        }
            A: FillArrays.Fill{Matrix{Float64}, 1, Tuple{InfiniteArrays.OneToInf{Int64}}}
              value: Array{Float64}((4, 4)) [1.0 0.0 0.1 0.0; 0.0 1.0 0.0 0.1; 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 1.0]
              axes: Tuple{InfiniteArrays.OneToInf{Int64}}
                1: InfiniteArrays.OneToInf{Int64} OneToInf()
            B: FillArrays.Fill{Matrix{Float64}, 1, Tuple{InfiniteArrays.OneToInf{Int64}}}
              value: Array{Float64}((4, 2)) [0.005000000000000001 0.0; 0.0 0.005000000000000001; 0.1 0.0; 0.0 0.1]
              axes: Tuple{InfiniteArrays.OneToInf{Int64}}
                1: InfiniteArrays.OneToInf{Int64} OneToInf()
            state_bounds: @NamedTuple{lb::Vector{Float64}, ub::Vector{Float64}}
              lb: Array{Float64}((4,)) [-Inf, -Inf, -5.0, -5.0]
              ub: Array{Float64}((4,)) [Inf, Inf, 5.0, 5.0]
            control_bounds: @NamedTuple{lb::Vector{Int64}, ub::Vector{Int64}}
              lb: Array{Int64}((2,)) [-10, -10]
              ub: Array{Int64}((2,)) [10, 10]
      2: LinearDynamics{
        FillArrays.Fill{Matrix{Float64}, 1, Tuple{InfiniteArrays.OneToInf{Int64}}}, 
        FillArrays.Fill{Matrix{Float64}, 1, Tuple{InfiniteArrays.OneToInf{Int64}}}, 
        @NamedTuple{lb::Vector{Float64}, ub::Vector{Float64}}, 
        @NamedTuple{lb::Vector{Int64}, ub::Vector{Int64}}}
            A: FillArrays.Fill{Matrix{Float64}, 1, Tuple{InfiniteArrays.OneToInf{Int64}}}
              value: Array{Float64}((4, 4)) [1.0 0.0 0.1 0.0; 0.0 1.0 0.0 0.1; 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 1.0]
              axes: Tuple{InfiniteArrays.OneToInf{Int64}}
                1: InfiniteArrays.OneToInf{Int64} OneToInf()
            B: FillArrays.Fill{Matrix{Float64}, 1, Tuple{InfiniteArrays.OneToInf{Int64}}}
              value: Array{Float64}((4, 2)) [0.005000000000000001 0.0; 0.0 0.005000000000000001; 0.1 0.0; 0.0 0.1]
              axes: Tuple{InfiniteArrays.OneToInf{Int64}}
                1: InfiniteArrays.OneToInf{Int64} OneToInf()
            state_bounds: @NamedTuple{lb::Vector{Float64}, ub::Vector{Float64}}
              lb: Array{Float64}((4,)) [-Inf, -Inf, -5.0, -5.0]
              ub: Array{Float64}((4,)) [Inf, Inf, 5.0, 5.0]
            control_bounds: @NamedTuple{lb::Vector{Int64}, ub::Vector{Int64}}
              lb: Array{Int64}((2,)) [-10, -10]
              ub: Array{Int64}((2,)) [10, 10]


      cost: 
      TimeSeparableTrajectoryGameCost{
        TrajectoryGamesExamples.var"#stage_cost#35"{Float64, typeof(LinearAlgebra.norm)}, 
        TrajectoryGamesExamples.var"#reducer#36", ZeroSumCostStructure
      } 
            stage_cost: 
            stage_cost (function of type TrajectoryGamesExamples.var"#stage_cost#35"{Float64, typeof(LinearAlgebra.norm)})

            control_penalty: Float64 0.1

            distance_metric: norm (function of type typeof(LinearAlgebra.norm))

            reducer: reducer (function of type TrajectoryGamesExamples.var"#reducer#36")

            structure: ZeroSumCostStructure ZeroSumCostStructure()

            discount_factor: Float64 1.0

      env: 
      PolygonEnvironment{LazySets.VPolytope{Float64, Vector{Float64}, Vector{Vector{Float64}}}}

          set:
          LazySets.VPolytope{Float64, Vector{Float64}, Vector{Vector{Float64}}}

          vertices: Array{Vector{Float64}}((5,))
                1: Array{Float64}((2,)) [-1.2360679774997894, 3.8042260651806146]
                2: Array{Float64}((2,)) [-4.0, 4.898587196589413e-16]
                3: Array{Float64}((2,)) [-1.2360679774997902, -3.804226065180614]
                4: Array{Float64}((2,)) [3.2360679774997894, -2.3511410091698934]
                5: Array{Float64}((2,)) [3.2360679774997902, 2.3511410091698917]
      
      coupling_constraints: Nothing nothing
)